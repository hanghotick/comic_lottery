<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Futuristic Particle System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Apply Inter font and basic body styling */
        body {
            font-family: "Inter", sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #000000; /* Deep black background from image */
            display: flex;
            flex-direction: column; /* Arrange items vertically */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem; /* Add some padding around the content */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        canvas {
            display: block;
            background-color: #000000; /* Match body background from image */
            border-radius: 1rem; /* Rounded corners for the canvas */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5); /* Subtle shadow */
            width: 90vw; /* Responsive width */
            height: 70vh; /* Responsive height, leaving space for controls/output */
            margin-bottom: 1rem; /* Space between canvas and controls */
            cursor: grab; /* Indicate draggable element */
        }

        canvas:active {
            cursor: grabbing; /* Indicate dragging in progress */
        }

        /* Controls and output area */
        .controls-output-container {
            background-color: #1a1a2e;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90vw; /* Match canvas width */
            max-width: 800px; /* Max width for larger screens */
            margin-top: 1rem; /* Space above controls */
        }

        .action-button {
            background-color: #6a05ad; /* Purple button */
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin-bottom: 0.75rem; /* Space between buttons */
        }

        .action-button:hover {
            background-color: #8c07d3;
            transform: translateY(-2px);
        }

        .action-button:active {
            transform: translateY(0);
        }

        #startButton {
            font-size: 1.2rem;
            padding: 1rem 2rem;
            margin-bottom: 1.5rem;
            background-color: #00bfff; /* Brighter blue for start button */
        }

        #startButton:hover {
            background-color: #00aacc;
        }

        #statusOutput {
            background-color: #2a2a4a;
            color: #e0e0e0;
            padding: 1rem;
            border-radius: 0.75rem;
            width: 100%;
            min-height: 50px; /* Ensure it's visible even when empty */
            text-align: center;
            font-size: 0.95rem;
            line-height: 1.4;
            display: flex; /* Use flex for centering content */
            align-items: center; /* Center vertically */
            justify-content: center; /* Center horizontally */
            word-break: break-word; /* Ensure long words breaks */
            margin-top: 1rem;
        }

        /* Message box styling */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9); /* Darker overlay */
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
            font-size: 1.1rem;
            max-width: 90vw; /* Responsive width */
            max-height: 90vh; /* Responsive height */
            overflow-y: auto; /* Scroll if content is too long */
            border: 2px solid #6a05ad; /* Purple border */
        }

        .message-box button {
            background-color: #6a05ad; /* Purple button */
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            margin-top: 1.5rem;
            transition: background-color 0.3s ease;
        }

        .message-box button:hover {
            background-color: #8c07d3;
        }

        .slider-group {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 1rem;
            color: #e0e0e0;
            font-size: 0.9rem;
        }

        .slider-group input[type="range"] {
            width: 80%;
            -webkit-appearance: none;
            height: 8px;
            background: #4a4a6a;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }

        .slider-group input[type="range"]:hover {
            opacity: 1;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #8c07d3;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #8c07d3;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        /* Countdown display styling */
        #countdownDisplay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5rem;
            font-weight: bold;
            color: #8c07d3; /* Purple color */
            text-shadow: 0 0 10px rgba(140, 7, 211, 0.8);
            z-index: 1001; /* Above everything else */
            display: none; /* Hidden by default */
        }

        /* Lucky History Styling - Removed */
    </style>
</head>
<body>
    <script>
        window.particles = [];
        console.log("Global script: window.particles initialized to:", window.particles);
    </script>

    <canvas id="starfieldCanvas" style="position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:0; pointer-events:none;"></canvas>
    <canvas id="particleCanvas"></canvas>

    <div class="controls-output-container">
        <div class="slider-group" style="margin-bottom:1.5rem;">
            <label for="languageSelect">Language / Nyelv</label>
            <select id="languageSelect" style="width:60%;padding:0.5em;margin-top:0.5em;border-radius:0.5em;border:1px solid #4a4a6a;background:#23234a;color:#e0e0e0;">
                <option value="en">English</option>
                <option value="hu">Magyar</option>
            </select>
        </div>
        <div class="slider-group">
            <label id="zoomSliderLabel" for="zoomSlider">Camera Zoom</label>
            <input type="range" id="zoomSlider" min="50" max="400" value="200" step="1" oninput="window.updateInitialCameraZoom(this.value)">
        </div>
        <div class="slider-group" style="margin-bottom:1.5rem;">
            <label id="personalLuckyInputLabel" for="personalLuckyInput">Personal Lucky Number</label>
            <input type="number" id="personalLuckyInput" min="1" step="1" placeholder="Enter your lucky number..." style="width:60%;padding:0.5em;margin-top:0.5em;border-radius:0.5em;border:1px solid #4a4a6a;background:#23234a;color:#e0e0e0;">
        </div>
        <button class="action-button" id="startButton">‚ñ∂Ô∏è Start Lucky Draw ‚ñ∂Ô∏è</button>
        <button class="action-button" id="restartButton">üîÑ Restart Simulation üîÑ</button>
        <div id="statusOutput" class="llm-output">
            Press Start to begin the Lucky Draw!
        </div>
    </div>

    <div id="countdownDisplay"></div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button onclick="window.hideMessageBox()">OK</button>
    </div>

    <script type="module">
        // --- Starfield/Nebula Background ---
        const starfieldCanvas = document.getElementById('starfieldCanvas');
        const starfieldCtx = starfieldCanvas.getContext('2d');
        let stars = [];
        let nebulaGradient = null;
        function resizeStarfield() {
            starfieldCanvas.width = window.innerWidth;
            starfieldCanvas.height = window.innerHeight;
            nebulaGradient = starfieldCtx.createRadialGradient(
                starfieldCanvas.width/2, starfieldCanvas.height/2, starfieldCanvas.width/8,
                starfieldCanvas.width/2, starfieldCanvas.height/2, starfieldCanvas.width/1.2
            );
            nebulaGradient.addColorStop(0, 'rgba(80,40,120,0.18)');
            nebulaGradient.addColorStop(0.5, 'rgba(40,20,60,0.10)');
            nebulaGradient.addColorStop(1, 'rgba(0,0,0,0.0)');
        }
        function initStarfield(numStars=120) {
            stars = [];
            for (let i=0; i<numStars; i++) {
                stars.push({
                    x: Math.random()*starfieldCanvas.width,
                    y: Math.random()*starfieldCanvas.height,
                    r: Math.random()*1.2+0.3,
                    vx: (Math.random()-0.5)*0.04,
                    vy: (Math.random()-0.5)*0.04,
                    alpha: Math.random()*0.5+0.5
                });
            }
        }
        function drawStarfield() {
            starfieldCtx.clearRect(0,0,starfieldCanvas.width,starfieldCanvas.height);
            // Nebula
            if (nebulaGradient) {
                starfieldCtx.fillStyle = nebulaGradient;
                starfieldCtx.fillRect(0,0,starfieldCanvas.width,starfieldCanvas.height);
            }
            // Stars
            for (let s of stars) {
                starfieldCtx.beginPath();
                starfieldCtx.arc(s.x, s.y, s.r, 0, 2*Math.PI);
                starfieldCtx.fillStyle = `rgba(200,200,255,${s.alpha})`;
                starfieldCtx.shadowColor = '#8c07d3';
                starfieldCtx.shadowBlur = 8;
                starfieldCtx.fill();
                starfieldCtx.shadowBlur = 0;
            }
        }
        function updateStarfield() {
            for (let s of stars) {
                s.x += s.vx;
                s.y += s.vy;
                if (s.x < 0) s.x += starfieldCanvas.width;
                if (s.x > starfieldCanvas.width) s.x -= starfieldCanvas.width;
                if (s.y < 0) s.y += starfieldCanvas.height;
                if (s.y > starfieldCanvas.height) s.y -= starfieldCanvas.height;
            }
        }
        function animateStarfield() {
            updateStarfield();
            drawStarfield();
            requestAnimationFrame(animateStarfield);
        }
        window.addEventListener('resize', ()=>{
            resizeStarfield();
            initStarfield();
        });
        resizeStarfield();
        initStarfield();
        animateStarfield();

        // Debugging: Initial state of window.particles (from module perspective, after imports)
        console.log("Script module (after imports) loaded. Initial window.particles:", window.particles);

        // --- Language Support ---
        const translations = {
            en: {
                cameraZoom: "Camera Zoom",
                personalLucky: "Personal Lucky Number",
                personalLuckyPlaceholder: "Enter your lucky number...",
                start: "‚ñ∂Ô∏è Start Lucky Draw ‚ñ∂Ô∏è",
                restart: "üîÑ Restart Simulation üîÑ",
                statusDefault: "Press Start to begin the Lucky Draw!",
                statusSwirl: "Spheres are swirling for luck...",
                statusSelected: "Lucky Numbers Selected!",
                ok: "OK",
                countdownGo: "GO!",
                luckyNumbers: "Your Lucky Numbers:",
                numerologySum: "Numerology Sum:",
                affirmation: "Affirmation:",
                luckyColor: "Lucky Color:",
                symbol: "Symbol:",
                personalLuckyTitle: "Your Personal Lucky Number:",
                errorNoParticles: "No particles to select from!",
                language: "Language / Nyelv",
                messageBoxTitle: "Numerology Fortune"
            },
            hu: {
                cameraZoom: "Kamera nagy√≠t√°s",
                personalLucky: "Szem√©lyes szerencsesz√°m",
                personalLuckyPlaceholder: "√çrd be a szerencsesz√°mod...",
                start: "‚ñ∂Ô∏è Sorsol√°s ind√≠t√°sa ‚ñ∂Ô∏è",
                restart: "üîÑ Szimul√°ci√≥ √∫jraind√≠t√°sa üîÑ",
                statusDefault: "Nyomd meg a Start gombot a sorsol√°shoz!",
                statusSwirl: "A g√∂mb√∂k szerencs√©t kavarnak...",
                statusSelected: "Sorsolt sz√°mok kiv√°lasztva!",
                ok: "OK",
                countdownGo: "RAJT!",
                luckyNumbers: "Sorsolt sz√°mok:",
                numerologySum: "Numerol√≥giai √∂sszeg:",
                affirmation: "Meger≈ës√≠t√©s:",
                luckyColor: "Szerencsesz√≠n:",
                symbol: "Szimb√≥lum:",
                personalLuckyTitle: "Szem√©lyes szerencsesz√°mod:",
                errorNoParticles: "Nincs el√©rhet≈ë g√∂mb a sorsol√°shoz!",
                language: "Nyelv / Language",
                messageBoxTitle: "Numerol√≥giai j√≥slat"
            }
        };
        let currentLang = 'en';
        function setLanguage(lang) {
            currentLang = lang;
            document.getElementById('zoomSliderLabel').textContent = translations[lang].cameraZoom;
            document.getElementById('personalLuckyInputLabel').textContent = translations[lang].personalLucky;
            document.getElementById('personalLuckyInput').placeholder = translations[lang].personalLuckyPlaceholder;
            document.getElementById('startButton').textContent = translations[lang].start;
            document.getElementById('restartButton').textContent = translations[lang].restart;
            document.getElementById('statusOutput').textContent = translations[lang].statusDefault;
            document.getElementById('languageSelect').previousElementSibling.textContent = translations[lang].language;
            document.getElementById('messageText').parentElement.querySelector('button').textContent = translations[lang].ok;
        }
        document.getElementById('languageSelect').addEventListener('change', function() {
            setLanguage(this.value);
        });

        // --- Three.js Setup ---
        // `window.particles` is now declared globally in a separate script tag above.
        let scene, camera, renderer, cubeWireframe;
        let initialParticleColor = new THREE.Color();

        // Global parameters - Adjusted for slower animation
        let numberOfParticles = 1000;
        let particleSpeedFactor = 0.002; // Reduced for slower motion
        let boxSize = 200;
        let particleRadius = 1.0;
        let damping = 0.9995; // Slightly increased for more damping (slower movement)

        // Galactic Motion Parameters - Adjusted for slower animation
        let gravitationalPull = 0.00002; // Reduced
        let orbitalVelocityFactor = 0.0002; // Reduced
        let galacticRandomMotion = 0.0002; // Reduced

        // Intergalactic Movement Parameters (Peculiar Velocities) - Adjusted for slower animation
        let peculiarVelocity = new THREE.Vector3(0.000005, 0.0000025, 0.000005); // Reduced
        let peculiarVelocityChangeRate = 0.00000005; // Reduced

        // Cosmic Expansion Parameters - Adjusted for slower animation
        let cosmicExpansionFactor = 0.00000005; // Reduced

        // Dynamic swirl parameters (will adjust these to reflect new names)
        let currentOrbitalVelocityFactor = orbitalVelocityFactor;
        let currentGravitationalPull = gravitationalPull;
        const maxOrbitalVelocityFactor = 0.0015; // Adjusted max for overall slower feel
        const maxGravitationalPull = 0.00004; // Adjusted max
        const swirlIncreaseRate = 0.000002; // Reduced for slower intensification

        // Mouse rotation variables (now global for consistent access)
        window.rotationSpeed = 0.005;
        window.autoRotationSpeed = 0.0005; // Reduced for slower automatic cube rotation

        // Mouse interaction for dragging
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;

        // Lucky particle selection variables
        const numberOfSelectedParticles = 6;
        let selectedParticlesArray = [];
        let countdownValue = 10; // Increased countdown value for longer selection process
    
        let countdownInterval;
        let countdownDisplay;
        window.luckyParticleSelected = false; // Expose to window
        let initialZoomValue;
        window.simulationStarted = false; // Expose to window // Controls if animation is active
        let explosionActive = false; // Flag for explosive reveal
        let explosionStartTime = 0; // To track when the explosion started
        const explosionDuration = 1500; // 1.5 seconds for the explosion fade animation

        // New variables for lining up and camera zoom
        let isLiningUp = false;
        let lineUpStartTime = 0;
        const lineUpDuration = 2000; // 2 seconds for particles to line up and camera to zoom
        let initialCameraZForLineUp;
        const targetCameraZ = 60; // Closer zoom for lined-up particles
        // Target positions for the 6 selected particles to line up horizontally in the center
        const targetParticlePositions = [
            new THREE.Vector3(-50, 0, 0),
            new THREE.Vector3(-30, 0, 0),
            new THREE.Vector3(-10, 0, 0),
            new THREE.Vector3(10, 0, 0),
            new THREE.Vector3(30, 0, 0),
            new THREE.Vector3(50, 0, 0)
        ];

        // Global particle color definition
        const particleColorHue = 270; // Default to purple-ish
        const particleColorSaturation = 70; // Default saturation
        const particleColorLightness = 60; // Default lightness


        // Initialize Three.js scene, camera, renderer
        function initThreeJS() {
            // Crucial check: Ensure THREE is defined before proceeding
            if (typeof THREE === 'undefined') {
                console.error("THREE.js library is not loaded. Cannot initialize Three.js scene.");
                window.showMessageBox("Error: 3D graphics library not loaded. Please try refreshing.");
                return;
            }

            scene = new THREE.Scene();

            // Camera setup
            initialZoomValue = parseFloat(document.getElementById('zoomSlider').value);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = initialZoomValue;
            camera.position.y = boxSize * 0.2;
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('particleCanvas') });
            renderer.setSize(window.innerWidth * 0.9, window.innerHeight * 0.7);
            renderer.setClearColor(0x000000, 1); // Deep black background

            // Create cube wireframe border
            const geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const edges = new THREE.EdgesGeometry(geometry);
            cubeWireframe = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x404080 }));
            scene.add(cubeWireframe);

            // Get reference to the countdown display
            countdownDisplay = document.getElementById('countdownDisplay');

            initParticles(); // Set up initial particle state

            window.addEventListener('resize', onWindowResize, false);

            // Mouse interaction event listeners
            const canvasElement = document.getElementById('particleCanvas');
            canvasElement.addEventListener('mousedown', onMouseDown, false);
            canvasElement.addEventListener('mousemove', onMouseMove, false);
            canvasElement.addEventListener('mouseup', onMouseUp, false);
            canvasElement.addEventListener('mouseleave', onMouseUp, false); // Treat mouse leaving as mouse up

            animate();
        }

        // Mouse event handlers
        function onMouseDown(event) {
            isDragging = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
            event.preventDefault(); // Prevent default browser drag behavior
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaX = event.clientX - previousMouseX;
            const deltaY = event.clientY - previousMouseY;

            // Rotate the scene based on mouse movement
            // Adjust sensitivity as needed
            scene.rotation.y += deltaX * 0.005; // Rotate around Y-axis for horizontal drag
            scene.rotation.x += deltaY * 0.005; // Rotate around X-axis for vertical drag

            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        // Function to create a CanvasTexture for text
        function createTextTexture(text, color = 'white', fontSize = 128) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const font = `${fontSize}px Arial`;

            context.font = font;
            const textMetrics = context.measureText(text);
            canvas.width = textMetrics.width + 20; // Add padding
            canvas.height = fontSize + 20; // Add padding

            context.font = font;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // Initialize particles as THREE.Mesh spheres
        function initParticles() {
            console.log("initParticles: Current window.particles.length before clearing:", window.particles.length); // Debugging log

            // Remove existing particles from scene and dispose geometries/materials
            window.particles.forEach(p => {
                scene.remove(p.mesh);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
                if (p.textMesh) {
                    if (p.mesh.children.includes(p.textMesh)) {
                        p.mesh.remove(p.textMesh);
                    }
                    p.textMesh.geometry.dispose();
                    p.textMesh.material.dispose();
                }
            });
            window.particles = [];
            selectedParticlesArray = [];
            window.luckyParticleSelected = false;
            explosionActive = false;
            isLiningUp = false;
            updateStatusOutput('statusDefault'); // Reset status text
            currentOrbitalVelocityFactor = orbitalVelocityFactor;
            currentGravitationalPull = gravitationalPull;

            console.log("initParticles: numberOfParticles is", numberOfParticles); // Debugging log

            const center = new THREE.Vector3(0, 0, 0);
            const sphereGeometry = new THREE.SphereGeometry(particleRadius, 16, 16);

            initialParticleColor.setHSL(particleColorHue / 360, particleColorSaturation / 100, particleColorLightness / 100);

            try { // Added try-catch for particle creation loop
                for (let i = 0; i < numberOfParticles; i++) {
                    let x = (Math.random() - 0.5) * boxSize;
                    let y = (Math.random() - 0.5) * boxSize;
                    let z = (Math.random() - 0.5) * boxSize;

                    const particlePos = new THREE.Vector3(x, y, z);
                    const directionFromCenter = new THREE.Vector3().subVectors(particlePos, center).normalize();

                    // Initial gravitational pull
                    const initialGravitationalForce = directionFromCenter.clone().multiplyScalar(-particlePos.length() * gravitationalPull);

                    // Initial orbital velocity
                    const axis = new THREE.Vector3(0, 1, 0); // Assume galactic plane is XZ
                    const initialTangentialVelocity = new THREE.Vector3().crossVectors(axis, directionFromCenter).normalize();
                    const initialDifferentialFactor = Math.max(0, 1 - (particlePos.length() / (boxSize / 2)));
                    initialTangentialVelocity.multiplyScalar(particlePos.length() * orbitalVelocityFactor * initialDifferentialFactor);

                    // Initial random galactic motion
                    const initialRandomMotion = new THREE.Vector3(
                        (Math.random() - 0.5) * galacticRandomMotion,
                        (Math.random() - 0.5) * galacticRandomMotion,
                        (Math.random() - 0.5) * galacticRandomMotion
                    );

                    // Initial peculiar velocity (global drift)
                    const initialPeculiarVelocity = peculiarVelocity.clone();

                    // Initial cosmic expansion (subtle outward push)
                    const initialCosmicExpansionForce = directionFromCenter.clone().multiplyScalar(cosmicExpansionFactor);

                    const initialVelocity = new THREE.Vector3()
                        .add(initialGravitationalForce)
                        .add(initialTangentialVelocity)
                        .add(initialRandomMotion)
                        .add(initialPeculiarVelocity)
                        .add(initialCosmicExpansionForce);

                    const material = new THREE.MeshBasicMaterial({ color: initialParticleColor.clone() });
                    const mesh = new THREE.Mesh(sphereGeometry, material);
                    mesh.position.set(x, y, z);
                    scene.add(mesh);

                    window.particles.push({ // Use window.particles
                        mesh: mesh,
                        velocity: initialVelocity,
                        number: i + 1
                    });
                    // Log first and last particle to confirm pushing
                    if (i === 0 || i === numberOfParticles - 1) {
                        console.log(`initParticles: Pushed particle ${i + 1}. Current array size: ${window.particles.length}`);
                    }
                }
            } catch (error) {
                console.error("Error during particle creation in initParticles:", error); // Ensure this is visible
                window.showMessageBox("Error creating particles. Check console for details.");
            }
            console.log("initParticles: Particles created, total:", window.particles.length); // Debugging log
            // Reset camera to initial position on re-init
            camera.position.z = initialZoomValue;
            camera.position.y = boxSize * 0.2;
            camera.lookAt(0, 0, 0);
            createParticleTrails();
        }

        // --- Particle Trails ---
        let particleTrails = [];
        function createParticleTrails() {
            particleTrails = window.particles.map(p => ({
                positions: [p.mesh.position.clone()],
                color: p.mesh.material.color.clone(),
                mesh: p.mesh
            }));
        }
        function updateParticleTrails() {
            for (let i=0; i<window.particles.length; i++) {
                const p = window.particles[i];
                const trail = particleTrails[i];
                if (!trail) continue;
                // Add new position
                trail.positions.push(p.mesh.position.clone());
                if (trail.positions.length > 16) trail.positions.shift();
            }
        }
        function renderParticleTrails() {
            // Remove old trail objects
            for (let t of particleTrails) {
                if (t.line) {
                    scene.remove(t.line);
                }
            }
            // Add new trail lines
            for (let i=0; i<particleTrails.length; i++) {
                const trail = particleTrails[i];
                if (trail.positions.length < 2) continue;
                const geometry = new THREE.BufferGeometry().setFromPoints(trail.positions);
                const material = new THREE.LineBasicMaterial({
                    color: trail.color,
                    transparent: true,
                    opacity: 0.25,
                    linewidth: 2
                });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                trail.line = line;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            updateParticles();
            updateParticleTrails();
            renderParticleTrails();

            // Automatic cube rotation only if not dragging and not lining up
            if (!window.luckyParticleSelected && !isDragging && !isLiningUp) {
                cubeWireframe.rotation.y += window.autoRotationSpeed;
                scene.rotation.y += window.autoRotationSpeed;

                // Intensify orbital motion and gravitational pull if simulation has started but selection hasn't happened
                if (window.simulationStarted) {
                    currentOrbitalVelocityFactor = Math.min(maxOrbitalVelocityFactor, currentOrbitalVelocityFactor + swirlIncreaseRate);
                    currentGravitationalPull = Math.min(maxGravitationalPull, currentGravitationalPull + swirlIncreaseRate * 0.1);
                }
            }
            renderer.render(scene, camera);
        }

        // Update particle positions and handle interactions/boundaries
        function updateParticles() {
            const center = new THREE.Vector3(0, 0, 0); // Define center for inward pull

            // Slowly change the direction of peculiar velocity
            peculiarVelocity.x += (Math.random() - 0.5) * peculiarVelocityChangeRate;
            peculiarVelocity.y += (Math.random() - 0.5) * peculiarVelocityChangeRate;
            peculiarVelocity.z += (Math.random() - 0.5) * peculiarVelocityChangeRate;

            for (let i = 0; i < window.particles.length; i++) { // Use window.particles
                const p = window.particles[i]; // Use window.particles
                const isSelected = selectedParticlesArray.includes(p);

                // Handle explosion (fading non-selected particles)
                if (explosionActive && !isSelected) {
                    const elapsedTime = Date.now() - explosionStartTime;
                    let opacity = 1 - (elapsedTime / explosionDuration);
                    p.mesh.material.opacity = Math.max(0, opacity);
                    if (p.mesh.material.opacity <= 0) {
                        p.mesh.visible = false;
                    }
                }

                // Apply damping
                p.velocity.multiplyScalar(damping);

                // Apply dynamic forces if not selected and not lining up
                if (!window.luckyParticleSelected && window.simulationStarted && !isLiningUp) {
                    const directionFromCenter = new THREE.Vector3().subVectors(p.mesh.position, center).normalize();
                    const distanceToCenter = p.mesh.position.length(); // Use length for distance to center

                    // Gravitational Pull (inward)
                    const gravitationalForce = directionFromCenter.clone().multiplyScalar(-distanceToCenter * currentGravitationalPull);
                    p.velocity.add(gravitationalForce);

                    // Orbital Velocity (tangential, differential rotation)
                    const axis = new THREE.Vector3(0, 1, 0); // Assume galactic plane is Y-axis for rotation
                    const tangentialVelocity = new THREE.Vector3().crossVectors(axis, directionFromCenter).normalize();
                    // Differential rotation: faster closer to center, slower further out
                    const differentialFactor = Math.max(0, 1 - (distanceToCenter / (boxSize / 2))); // Stronger closer to center
                    p.velocity.add(tangentialVelocity.multiplyScalar(distanceToCenter * currentOrbitalVelocityFactor * differentialFactor));

                    // Random Galactic Motion
                    p.velocity.x += (Math.random() - 0.5) * galacticRandomMotion;
                    p.velocity.y += (Math.random() - 0.5) * galacticRandomMotion;
                    p.velocity.z += (Math.random() - 0.5) * galacticRandomMotion;

                    // Intergalactic Movement (Peculiar Velocities)
                    p.velocity.add(peculiarVelocity);

                    // Cosmic Expansion (very subtle outward push)
                    const cosmicExpansionForce = directionFromCenter.clone().multiplyScalar(cosmicExpansionFactor);
                    p.velocity.add(cosmicExpansionForce);

                    // Dynamic color shift during swirl
                    p.mesh.material.color.setHSL(
                        (particleColorHue / 360 + Math.sin(Date.now() * 0.0001 + i * 0.01) * 0.05) % 1, // Subtle hue shift
                        particleColorSaturation / 100,
                        particleColorLightness / 100
                    );
                } else if (window.luckyParticleSelected) {
                    // Once selected, keep selected particles' colors vibrant
                    if (isSelected) {
                        p.mesh.material.color.setHSL(particleColorHue / 360, particleColorSaturation / 100, particleColorLightness / 100);
                    }
                }

                // Handle lining up animation for selected particles
                if (isLiningUp && isSelected) {
                    const elapsedTime = Date.now() - lineUpStartTime;
                    let t = Math.min(1, elapsedTime / lineUpDuration); // Animation progress (0 to 1)

                    const selectedIndex = selectedParticlesArray.indexOf(p);
                    if (selectedIndex !== -1 && targetParticlePositions[selectedIndex]) {
                        // Interpolate position
                        p.mesh.position.lerp(targetParticlePositions[selectedIndex], t);
                        // Stop particle's own velocity once lining up starts
                        p.velocity.set(0, 0, 0);
                    }
                } else if (isLiningUp && !isSelected) {
                    // If lining up, and not selected, ensure non-selected particles are fully hidden
                    p.mesh.material.opacity = 0;
                    p.mesh.visible = false;
                }


                // Ensure minimum speed for continuous floating (only if not lining up)
                const minContinuousSpeed = 0.0005; // Define locally if not global
                if (!isLiningUp && p.velocity.length() < minContinuousSpeed) {
                    p.velocity.x += (Math.random() - 0.5) * particleSpeedFactor * 0.5;
                    p.velocity.y += (Math.random() - 0.5) * particleSpeedFactor * 0.5;
                    p.velocity.z += (Math.random() - 0.5) * particleSpeedFactor * 0.5;
                }

                p.mesh.position.add(p.velocity);

                // Boundary collision (bounce off cube walls) and color change
                const halfBox = boxSize / 2;
                let collided = false;

                // Check and clamp position for X-axis
                if (p.mesh.position.x + particleRadius > halfBox) {
                    p.velocity.x *= -1;
                    p.mesh.position.x = halfBox - particleRadius;
                    collided = true;
                } else if (p.mesh.position.x - particleRadius < -halfBox) {
                    p.velocity.x *= -1;
                    p.mesh.position.x = -halfBox + particleRadius;
                    collided = true;
                }

                // Check and clamp position for Y-axis
                if (p.mesh.position.y + particleRadius > halfBox) {
                    p.velocity.y *= -1;
                    p.mesh.position.y = halfBox - particleRadius;
                    collided = true;
                } else if (p.mesh.position.y - particleRadius < -halfBox) {
                    p.velocity.y *= -1;
                    p.mesh.position.y = -halfBox + particleRadius;
                    collided = true;
                }

                // Check and clamp position for Z-axis
                if (p.mesh.position.z + particleRadius > halfBox) {
                    p.velocity.z *= -1;
                    p.mesh.position.z = halfBox - particleRadius;
                    collided = true;
                } else if (p.mesh.position.z - particleRadius < -halfBox) {
                    p.velocity.z *= -1;
                    p.mesh.position.z = -halfBox + particleRadius;
                    collided = true;
                }

                // Change color if collision occurred (only before selection)
                if (collided && !window.luckyParticleSelected) {
                    const newColor = new THREE.Color();
                    const newHue = Math.random();
                    const newSaturation = 0.7 + Math.random() * 0.3;
                    const newLightness = 0.5 + Math.random() * 0.3;
                    newColor.setHSL(newHue, newSaturation, newLightness);
                    p.mesh.material.color.copy(newColor);
                }
            }

            // Camera zoom animation during lining up
            if (isLiningUp) {
                const elapsedTime = Date.now() - lineUpStartTime;
                let t = Math.min(1, elapsedTime / lineUpDuration);
                camera.position.z = THREE.MathUtils.lerp(initialCameraZForLineUp, targetCameraZ, t);
                camera.lookAt(0, 0, 0); // Keep camera focused on the center
            }
        }

        function onWindowResize() {
            const canvasElement = document.getElementById('particleCanvas');
            canvasElement.width = window.innerWidth * 0.9;
            canvasElement.height = window.innerHeight * 0.7;

            camera.aspect = canvasElement.width / canvasElement.height;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasElement.width, canvasElement.height);
        }

        // Function to update initial camera zoom (from slider)
        window.updateInitialCameraZoom = function(value) { // Expose to window
            initialZoomValue = parseFloat(value);
            if (!window.luckyParticleSelected) {
                camera.position.z = initialZoomValue;
                camera.updateProjectionMatrix();
            }
        }

        // --- Game Flow Functions ---
        // startLuckyDraw is now exposed globally via window.startLuckyDraw in the module script
        window.startLuckyDraw = function() {
            // If simulation is already started, restart it instead of showing a message
            if (window.simulationStarted) {
                window.restartSimulation();
                return;
            }
            window.simulationStarted = true;
            updateStatusOutput('statusSwirl');
            window.startCountdown();
        };

        // Expose startCountdown to the global scope
        window.startCountdown = function() {
            clearInterval(countdownInterval);
            countdownDisplay.style.display = 'block';
            countdownValue = 10; // Set countdown to 10 seconds
            countdownDisplay.textContent = countdownValue;

            countdownInterval = setInterval(() => {
                countdownValue--;
                if (countdownValue > 0) {
                    countdownDisplay.textContent = countdownValue;
                } else {
                    countdownDisplay.textContent = translations[currentLang].countdownGo;
                    clearInterval(countdownInterval);
                    setTimeout(() => {
                        window.autoSelectLuckyParticles();
                    }, 500);
                }
            }, 1000);
        };

        // New function to start the lining up animation and camera zoom
        function startLiningUpAnimation(selectedNumbers, sumOfNumbers) {
            isLiningUp = true;
            lineUpStartTime = Date.now();
            initialCameraZForLineUp = camera.position.z; // Store current camera Z before zooming

            setTimeout(() => {
                isLiningUp = false; // End lining up animation
                displayNumerologyFortune(sumOfNumbers, selectedNumbers); // Display fortune after animation
            }, lineUpDuration);
        }

        // Expose autoSelectLuckyParticles to the global scope
        window.autoSelectLuckyParticles = function() {
            console.log("autoSelectLuckyParticles: Current window.particles array length:", window.particles.length); // Debugging log
            if (window.particles.length === 0) { // Use window.particles
                window.showMessageBox(translations[currentLang].errorNoParticles);
                return;
            }

            selectedParticlesArray = [];
            // Create a fresh array of available indices for unbiased selection.
            // This ensures every particle has an equal chance of being picked.
            const availableIndices = Array.from({ length: window.particles.length }, (_, i) => i);

            for (let i = 0; i < numberOfSelectedParticles; i++) {
                if (availableIndices.length === 0) break;

                // Randomly select an index from the available pool.
                // This provides equal probability for all remaining particles.
                const randomIndex = Math.floor(Math.random() * availableIndices.length);
                // Get the actual particle index and remove it from the available pool.
                // This ensures independence of outcomes and no duplicate selections.
                const particleIndex = availableIndices.splice(randomIndex, 1)[0];
                const p = window.particles[particleIndex]; // Use window.particles

                selectedParticlesArray.push(p);

                // Add text mesh for each selected particle
                const textTexture = createTextTexture(String(p.number), 'white', 128);
                const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true, side: THREE.DoubleSide });
                const textScaleFactor = 0.5;
                const textGeometry = new THREE.PlaneGeometry(
                    textTexture.image.width / 100 * textScaleFactor,
                    textTexture.image.height / 100 * textScaleFactor
                );
                p.textMesh = new THREE.Mesh(textGeometry, textMaterial);
                p.textMesh.position.z = particleRadius + 0.1;
                p.mesh.add(p.textMesh);
            }

            explosionActive = true; // Trigger fading of non-selected particles
            explosionStartTime = Date.now(); // Record start time of explosion
            window.particles.forEach(p => { // Use window.particles
                if (!selectedParticlesArray.includes(p)) {
                    p.mesh.material.transparent = true; // Enable transparency for fading
                }
            });

            window.luckyParticleSelected = true;
            updateStatusOutput('statusSelected');

            const selectedNumbers = selectedParticlesArray.map(p => p.number).join(', ');
            const sumOfNumbers = selectedParticlesArray.reduce((sum, p) => sum + p.number, 0);
            
            // Delay displaying the numerology fortune until after the explosion animation
            setTimeout(() => {
                explosionActive = false; // Stop explosion logic after duration
                countdownDisplay.style.display = 'none'; // Hide the "GO!" text
                startLiningUpAnimation(selectedNumbers, sumOfNumbers); // Start lining up and camera zoom
            }, explosionDuration);
        };

        // Expose restartSimulation to the global scope
        window.restartSimulation = function() {
            clearInterval(countdownInterval);
            countdownDisplay.style.display = 'none';
            countdownValue = 10; // Reset countdown for restart
            window.simulationStarted = false;
            explosionActive = false;
            isLiningUp = false; // Reset lining up flag

            initParticles(); // Re-initialize particles and scene

            camera.position.z = initialZoomValue;
            camera.position.y = boxSize * 0.2;
            camera.lookAt(0, 0, 0);
            updateStatusOutput('statusDefault');
        };

        // --- Numerology Logic ---
        function reduceToSingleDigit(number) {
            if (number === 11 || number === 22 || number === 33) {
                return number; // Master numbers
            }
            let sum = 0;
            while (number > 0 || sum > 9) {
                if (number === 0) {
                    number = sum;
                    sum = 0;
                }
                sum += number % 10;
                number = Math.floor(number / 10);
            }
            return sum;
        }

        function getNumerologyMeaning(number) {
            switch (number) {
                case 1: return "The Leader: New beginnings, independence, and strong will. You are destined to forge your own path.";
                case 2: return "The Harmonizer: Balance, cooperation, and diplomacy. Your path is one of partnership and understanding.";
                case 3: return "The Creator: Creativity, communication, and joy. Express yourself and inspire others with your vibrant energy.";
                case 4: return "The Builder: Stability, hard work, and strong foundations. Diligence will lead you to lasting success.";
                case 5: return "The Adventurer: Freedom, change, and adaptability. Embrace new experiences and explore the world around you.";
                case 6: return "The Nurturer: Responsibility, harmony, and compassion. Your focus is on home, family, and service to others.";
                case 7: return "The Seeker: Spirituality, introspection, and wisdom. Your journey is one of deep thought and discovery.";
                case 8: return "The Achiever: Abundance, power, and ambition. You have the potential for great material and personal success.";
                case 9: return "The Humanitarian: Completion, compassion, and universal love. Your purpose is to serve humanity.";
                case 11: return "The Master Intuitive: High intuition, inspiration, and spiritual insight. You are a channel for higher truths.";
                case 22: return "The Master Builder: Practical idealism, vision, and large-scale creation. You can manifest great dreams.";
                case 33: return "The Master Teacher: Compassionate service, universal love, and healing. You are here to uplift humanity.";
                default: return "An unknown cosmic energy surrounds your numbers. Explore further!";
            }
        }

        function getNumerologyAffirmation(number) {
            switch (number) {
                case 1: return { affirmation: "I am a leader. I boldly create my own destiny.", color: "Red", symbol: "Sun" };
                case 2: return { affirmation: "I attract harmony and partnership into my life.", color: "Orange", symbol: "Moon" };
                case 3: return { affirmation: "I express my creativity and joy freely.", color: "Yellow", symbol: "Triangle" };
                case 4: return { affirmation: "I build strong foundations for lasting success.", color: "Green", symbol: "Square" };
                case 5: return { affirmation: "I embrace change and adventure with confidence.", color: "Blue", symbol: "Star" };
                case 6: return { affirmation: "I nurture myself and others with compassion.", color: "Indigo", symbol: "Heart" };
                case 7: return { affirmation: "I trust my intuition and seek deeper wisdom.", color: "Violet", symbol: "Lotus" };
                case 8: return { affirmation: "I am abundant and achieve my goals.", color: "Gold", symbol: "Infinity" };
                case 9: return { affirmation: "I share love and kindness with the world.", color: "Silver", symbol: "Circle" };
                case 11: return { affirmation: "I am inspired and guided by higher wisdom.", color: "White", symbol: "Lightning" };
                case 22: return { affirmation: "I manifest my grandest dreams into reality.", color: "Turquoise", symbol: "Pyramid" };
                case 33: return { affirmation: "I uplift others with love and healing.", color: "Pink", symbol: "Dove" };
                default: return { affirmation: "Embrace your unique cosmic energy!", color: "Mystery", symbol: "?" };
            }
        }

        function displayNumerologyFortune(totalSum, selectedNumbersString) {
            const numerologyNumber = reduceToSingleDigit(totalSum);
            const meaning = getNumerologyMeaning(numerologyNumber);
            const { affirmation, color, symbol } = getNumerologyAffirmation(numerologyNumber);

            // Personal Lucky Number logic
            let personalLucky = document.getElementById('personalLuckyInput').value;
            let personalLuckyMsg = '';
            if (personalLucky) {
                const personalNum = reduceToSingleDigit(parseInt(personalLucky));
                const personalMeaning = getNumerologyMeaning(personalNum);
                const personalAff = getNumerologyAffirmation(personalNum);
                personalLuckyMsg = `
                    <div style="margin-top:1.2em;padding:1em;background:#23234a;border-radius:0.7em;">
                        <span style="font-weight:bold;font-size:1.1em;">${translations[currentLang].personalLuckyTitle} ${personalLucky} ‚Üí ${personalNum}</span><br>
                        <span>${personalMeaning}</span><br>
                        <span style=\"color:#8c07d3;font-style:italic;\">${translations[currentLang].affirmation} ${personalAff.affirmation}</span><br>
                        <span style=\"color:#00bfff;\">${translations[currentLang].luckyColor} ${personalAff.color}</span> &nbsp; <span style=\"color:#ffd700;\">${translations[currentLang].symbol} ${personalAff.symbol}</span>
                    </div>
                `;
            }

            const message = `
                <p style=\"font-weight: bold; font-size: 1.2em; margin-bottom: 0.5em;\">${translations[currentLang].luckyNumbers} ${selectedNumbersString}</p>
                <p style=\"font-weight: bold; font-size: 1.5em; margin-bottom: 1em;\">${translations[currentLang].numerologySum} ${numerologyNumber}</p>
                <p>${meaning}</p>
                <div style=\"margin-top:0.8em;padding:0.7em;background:#18182e;border-radius:0.7em;\">
                    <span style=\"color:#8c07d3;font-style:italic;\">${translations[currentLang].affirmation} ${affirmation}</span><br>
                    <span style=\"color:#00bfff;\">${translations[currentLang].luckyColor} ${color}</span> &nbsp; <span style=\"color:#ffd700;\">${translations[currentLang].symbol} ${symbol}</span>
                </div>
                ${personalLuckyMsg}
            `;
            window.showMessageBox(message);
        }

        // Initialize and start animation when the window loads
        window.onload = async function() {
            console.log("window.onload: Starting initialization.");
            console.log("window.onload: window.particles before initThreeJS:", window.particles);
            initThreeJS();
            onWindowResize();

            // Attach event listener to the start button
            const startButton = document.getElementById('startButton');
            if (startButton) {
                startButton.addEventListener('click', window.startLuckyDraw);
            }

            console.log("window.onload: Initialization complete.");
        };

        // Patch status messages and button text in game logic
        function updateStatusOutput(key) {
            document.getElementById('statusOutput').textContent = translations[currentLang][key];
        }

        // Patch all statusOutput and message usages in game logic
        // Example: updateStatusOutput('statusSwirl');
        // In game logic, replace direct statusOutput.textContent assignments:
        // document.getElementById('statusOutput').textContent = 'Spheres are swirling for luck...';
        // with updateStatusOutput('statusSwirl');
        // In initParticles:
        // updateStatusOutput('statusDefault'); // Reset status text
        // In startLuckyDraw:
        // updateStatusOutput('statusSwirl');
        // In autoSelectLuckyParticles:
        // updateStatusOutput('statusSelected');
        // In restartSimulation:
        // updateStatusOutput('statusDefault');
        // In error case:
        // window.showMessageBox(translations[currentLang].errorNoParticles);
        // In countdown:
        // countdownDisplay.textContent = translations[currentLang].countdownGo;
    </script>
</body>
</html>
