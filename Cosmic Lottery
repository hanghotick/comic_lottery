<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Futuristic Particle System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Apply Inter font and basic body styling */
        body {
            font-family: "Inter", sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #0d0d1a; /* Very dark background */
            display: flex;
            flex-direction: column; /* Arrange items vertically */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem; /* Add some padding around the content */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        canvas {
            display: block;
            background-color: #0d0d1a; /* Match body background */
            border-radius: 1rem; /* Rounded corners for the canvas */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5); /* Subtle shadow */
            width: 90vw; /* Responsive width */
            height: 70vh; /* Responsive height, leaving space for controls/output */
            margin-bottom: 1rem; /* Space between canvas and controls */
            cursor: grab; /* Indicate draggable */
        }

        canvas.grabbing {
            cursor: grabbing; /* Indicate dragging */
        }

        /* Controls and output area */
        .controls-output-container {
            background-color: #1a1a2e;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90vw; /* Match canvas width */
            max-width: 800px; /* Max width for larger screens */
        }

        .input-group {
            display: flex;
            gap: 0.5rem;
            width: 100%;
            margin-bottom: 1rem;
            justify-content: center; /* Center the input and button */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        .input-group input[type="text"] {
            flex-grow: 1; /* Allow input to take available space */
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #4a4a6a;
            background-color: #2a2a4a;
            color: #e0e0e0;
            font-size: 1rem;
            max-width: 60%; /* Limit input width */
        }

        .action-button {
            background-color: #6a05ad; /* Purple button */
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        .action-button:hover {
            background-color: #8c07d3;
            transform: translateY(-2px);
        }

        .action-button:active {
            transform: translateY(0);
        }

        .llm-output {
            background-color: #2a2a4a;
            color: #e0e0e0;
            padding: 1rem;
            border-radius: 0.75rem;
            width: 100%;
            min-height: 50px; /* Ensure it's visible even when empty */
            text-align: center;
            font-size: 0.95rem;
            line-height: 1.4;
            display: flex; /* Use flex for centering content */
            align-items: center; /* Center vertically */
            justify-content: center; /* Center horizontally */
            word-break: break-word; /* Ensure long words break */
        }

        /* Message box styling */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
            font-size: 1.1rem;
        }

        .message-box button {
            background-color: #6a05ad; /* Purple button */
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            margin-top: 1rem;
            transition: background-color 0.3s ease;
        }

        .message-box button:hover {
            background-color: #8c07d3;
        }

        .slider-group {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 1rem;
            color: #e0e0e0;
            font-size: 0.9rem;
        }

        .slider-group input[type="range"] {
            width: 80%;
            -webkit-appearance: none;
            height: 8px;
            background: #4a4a6a;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }

        .slider-group input[type="range"]:hover {
            opacity: 1;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #8c07d3;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #8c07d3;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        /* Countdown display styling */
        #countdownDisplay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5rem;
            font-weight: bold;
            color: #8c07d3; /* Purple color */
            text-shadow: 0 0 10px rgba(140, 7, 211, 0.8);
            z-index: 1001; /* Above everything else */
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>

    <div class="controls-output-container">
        <div class="input-group">
            <input type="text" id="moodInput" placeholder="Enter a mood (e.g., 'calm', 'energetic')">
            <button class="action-button" onclick="applyMoodToParticles()">âœ¨ Apply Mood âœ¨</button>
        </div>
        <div class="slider-group">
            <label for="zoomSlider">Initial Zoom:</label>
            <input type="range" id="zoomSlider" min="100" max="500" value="160" oninput="updateInitialCameraZoom(this.value)">
        </div>
        <button class="action-button" onclick="restartSimulation()">ðŸ”„ Restart Simulation ðŸ”„</button>
        <button class="action-button" onclick="getParticleInsight()">âœ¨ Get Particle Insight âœ¨</button>
        <button class="action-button" onclick="narrateParticleScene()">âœ¨ Narrate Scene âœ¨</button>
        <div id="llmOutput" class="llm-output">
            Click a button to interact with the AI!
        </div>
    </div>

    <div id="countdownDisplay"></div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>

    <script>
        // Global variables for Firebase configuration (if needed, currently not used)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Three.js setup
        let scene, camera, renderer, cubeWireframe, spotLight, spotLightTarget;
        let particles = []; // Array of { mesh, velocity, originalPosition, number }
        let initialParticleColor = new THREE.Color();

        // Global parameters, now modifiable by LLM
        let numberOfParticles = 1000;
        let particleSpeedFactor = 0.015; // Slightly increased for initial energy
        let boxSize = 200;
        let particleRadius = 1.0;
        let mouseReactionRadius = 80;
        let mousePushForce = 1.5;
        let damping = 0.995; // Less damping for continuous movement
        let minContinuousSpeed = 0.008; // Higher minimum speed to ensure they never stop
        let whirlwindStrength = 0.002; // Increased initial whirlwind
        let inwardSpiralFactor = 0.00005;
        let restoringForceStrength = 0; // **Removed: Particles will not return to original position**
        let particleColorHue = 240;
        let particleColorSaturation = 80;
        let particleColorLightness = 65;

        // Mouse rotation variables
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        const rotationSpeed = 0.005;
        const autoRotationSpeed = 0.001; // New: Speed for automatic cube rotation

        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let mouse3D = new THREE.Vector3();

        // Lucky particle selection variables
        let selectedParticle = null; // Stores the selected particle object
        let countdownValue = 3;
        let countdownInterval;
        let countdownDisplay;
        let luckyParticleSelected = false; // Flag to control camera behavior
        let initialZoomValue; // To store the initial zoom from the slider
        let simulationStarted = false; // New flag to control countdown start
        let initialInteractionListenerAdded = false; // Flag to prevent multiple listeners
        let explosionActive = false; // Flag for explosive reveal

        // Shake gesture variables
        let lastMouseX = 0;
        let lastMouseY = 0;
        let shakeThreshold = 10; // Pixels moved per frame to count as a shake
        let shakeCount = 0;
        let maxShakeCount = 5; // Number of shakes to trigger countdown
        let shakeTimeout;

        // Temporary vectors for camera calculations
        const targetCameraPosition = new THREE.Vector3();
        const targetCameraLookAt = new THREE.Vector3();
        const cameraLerpFactor = 0.05; // Smoothness of camera transition
        const zoomInDistance = particleRadius * 8; // Adjusted zoom distance for better visibility of the number

        // Function to display messages in a custom message box instead of alert()
        function showMessageBox(message) {
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            messageBox.textContent = message;
            messageBox.style.display = 'block';
        }

        // Function to hide the custom message box
        function hideMessageBox() {
            document.getElementById('messageBox').style.display = 'none';
        }

        // Initialize Three.js scene, camera, renderer
        function initThreeJS() {
            scene = new THREE.Scene();

            // Camera setup
            initialZoomValue = parseFloat(document.getElementById('zoomSlider').value);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = initialZoomValue;
            camera.position.y = boxSize * 0.2;
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('particleCanvas') });
            renderer.setSize(window.innerWidth * 0.9, window.innerHeight * 0.7);
            renderer.setClearColor(0x0d0d1a, 1);

            // Create cube wireframe border
            const geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const edges = new THREE.EdgesGeometry(geometry);
            cubeWireframe = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x404080 }));
            scene.add(cubeWireframe);

            // Add a spotlight for the "spotlight effect"
            spotLight = new THREE.SpotLight(0xffffff, 1.5); // White light, intensity
            spotLight.angle = Math.PI / 8; // Narrow beam
            spotLight.penumbra = 0.5; // Soft edge
            spotLight.decay = 0.1; // Light fades with distance
            spotLight.distance = 500; // Max distance of light
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;
            scene.add(spotLight);

            spotLightTarget = new THREE.Object3D(); // Target for the spotlight
            scene.add(spotLightTarget);
            spotLight.target = spotLightTarget;
            spotLight.position.set(0, boxSize * 0.7, 0); // Start above the cube
            spotLightTarget.position.set(0, 0, 0); // Initially point at center
            spotLight.visible = false; // Hidden initially

            // Get reference to the countdown display
            countdownDisplay = document.getElementById('countdownDisplay');

            initParticles(); // Call initParticles here to set up initial particle state

            // Event listeners for mouse interaction (particle pushing)
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseleave', onMouseLeave, false);

            // Event listeners for cube rotation
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseDrag, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('mouseout', onMouseUp, false);

            window.addEventListener('resize', onWindowResize, false);

            // Add initial interaction listener to start countdown (for shake gesture)
            addInitialInteractionListener();

            animate();
        }

        // Function to add the initial interaction listener for countdown start
        function addInitialInteractionListener() {
            if (!initialInteractionListenerAdded) {
                const startInteraction = (event) => {
                    if (!simulationStarted) {
                        // For shake gesture, we need to track movement, not just click
                        // The actual startCountdown will be triggered by the shake detection in onMouseMove/onMouseDrag
                        // This listener just ensures the simulation is "ready" for interaction
                        simulationStarted = false; // Reset to false, shake gesture will set it to true
                    }
                };
                // Listen for any mouse/touch movement to enable shake detection
                renderer.domElement.addEventListener('mousemove', startInteraction, false);
                renderer.domElement.addEventListener('touchmove', startInteraction, false);
                initialInteractionListenerAdded = true;
            }
        }

        // Function to create a CanvasTexture for text
        function createTextTexture(text, color = 'white', fontSize = 128) { // Increased font size to 128
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const font = `${fontSize}px Arial`;

            context.font = font;
            const textMetrics = context.measureText(text);
            canvas.width = textMetrics.width + 20; // Add padding
            canvas.height = fontSize + 20; // Add padding

            context.font = font;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // Initialize particles with whirlwind motion and initial colors
        function initParticles() {
            // Remove existing particles from scene and dispose geometries/materials
            particles.forEach(p => {
                scene.remove(p.mesh);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
                if (p.textMesh) { // Dispose text mesh if it exists
                    scene.remove(p.textMesh);
                    p.textMesh.geometry.dispose();
                    p.textMesh.material.dispose();
                }
            });
            particles = []; // Clear the array
            selectedParticle = null; // Reset selected particle
            luckyParticleSelected = false; // Reset flag
            explosionActive = false; // Reset explosion flag

            const center = new THREE.Vector3(0, 0, 0);
            const sphereGeometry = new THREE.SphereGeometry(particleRadius, 16, 16); // Increased segments for smoother sphere

            initialParticleColor.setHSL(particleColorHue / 360, particleColorSaturation / 100, particleColorLightness / 100);

            for (let i = 0; i < numberOfParticles; i++) {
                let x = (Math.random() - 0.5) * boxSize;
                let y = (Math.random() - 0.5) * boxSize;
                let z = (Math.random() - 0.5) * boxSize;

                const particlePos = new THREE.Vector3(x, y, z);
                const directionFromCenter = new THREE.Vector3().subVectors(particlePos, center).normalize();

                const axis = new THREE.Vector3(0, 1, 0);
                const tangentialVelocity = new THREE.Vector3().crossVectors(axis, directionFromCenter).normalize();

                const distanceToCenter = particlePos.distanceTo(center);
                const inwardVelocity = directionFromCenter.clone().multiplyScalar(-distanceToCenter * inwardSpiralFactor);

                const initialVelocity = tangentialVelocity.multiplyScalar(distanceToCenter * whirlwindStrength).add(inwardVelocity);
                initialVelocity.add(new THREE.Vector3(
                    (Math.random() - 0.5) * particleSpeedFactor,
                    (Math.random() - 0.5) * particleSpeedFactor,
                    (Math.random() - 0.5) * particleSpeedFactor
                ));

                const material = new THREE.MeshBasicMaterial({ color: initialParticleColor.clone() });
                const mesh = new THREE.Mesh(sphereGeometry, material);
                mesh.position.set(x, y, z);
                scene.add(mesh);

                particles.push({
                    mesh: mesh,
                    velocity: initialVelocity,
                    number: i + 1 // Assign a unique number to each particle
                });
            }
            // Reset camera to initial position on re-init
            camera.position.z = initialZoomValue;
            camera.position.y = boxSize * 0.2;
            camera.lookAt(0, 0, 0);

            // Hide spotlight on init
            if (spotLight) {
                spotLight.visible = false;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            updateParticles();

            // Automatic cube rotation if no lucky particle is selected
            if (!luckyParticleSelected && !simulationStarted) { // Only auto-rotate before interaction starts countdown
                cubeWireframe.rotation.y += autoRotationSpeed;
                scene.rotation.y += autoRotationSpeed;

                // Animate spotlight if not selected and countdown hasn't started
                spotLight.visible = true; // Make spotlight visible
                const time = Date.now() * 0.0005;
                const radius = boxSize * 0.8;
                spotLight.position.x = Math.cos(time) * radius;
                spotLight.position.z = Math.sin(time) * radius;
                spotLight.position.y = boxSize * 0.7; // Keep it above

                spotLightTarget.position.x = Math.sin(time * 0.5) * boxSize * 0.2;
                spotLightTarget.position.z = Math.cos(time * 0.5) * boxSize * 0.2;
            } else if (luckyParticleSelected) {
                spotLight.visible = false; // Hide spotlight once particle is selected
            }


            // Camera follow logic for selected particle
            if (luckyParticleSelected && selectedParticle) {
                // Calculate target camera position (behind and slightly above the particle)
                targetCameraLookAt.copy(selectedParticle.mesh.position);

                // Position camera directly in front of the particle, slightly offset for visibility
                const offset = new THREE.Vector3(0, 0, zoomInDistance);
                offset.applyQuaternion(selectedParticle.mesh.quaternion);
                targetCameraPosition.copy(selectedParticle.mesh.position).add(offset);

                // Smoothly move camera
                camera.position.lerp(targetCameraPosition, cameraLerpFactor);
                camera.lookAt(targetCameraLookAt);

                // Update text mesh position and orientation
                if (selectedParticle.textMesh) {
                    selectedParticle.textMesh.position.copy(selectedParticle.mesh.position);
                    // Make text face the camera
                    selectedParticle.textMesh.quaternion.copy(camera.quaternion);
                    // Offset text slightly in front of the sphere
                    const textOffset = new THREE.Vector3(0, 0, particleRadius + 0.5);
                    textOffset.applyQuaternion(camera.quaternion);
                    selectedParticle.textMesh.position.add(textOffset);
                }
            }


            renderer.render(scene, camera);
        }

        // Update particle positions and handle interactions/boundaries
        function updateParticles() {
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];

                // If explosion is active and this isn't the selected particle, fade it out
                if (explosionActive && p !== selectedParticle) {
                    p.mesh.material.opacity -= 0.02; // Fade out speed
                    if (p.mesh.material.opacity <= 0) {
                        p.mesh.visible = false; // Hide completely
                    }
                }

                // Apply damping
                p.velocity.multiplyScalar(damping);

                // Ensure minimum speed for continuous floating (never stop)
                if (p.velocity.length() < minContinuousSpeed) {
                    p.velocity.x += (Math.random() - 0.5) * particleSpeedFactor * 0.5;
                    p.velocity.y += (Math.random() - 0.5) * particleSpeedFactor * 0.5;
                    p.velocity.z += (Math.random() - 0.5) * particleSpeedFactor * 0.5;
                }

                // Mouse interaction (particle pushing) - only if not dragging for rotation and no particle selected
                if (mouse.isMoving && mouse3D.x !== undefined && !isDragging && !luckyParticleSelected) {
                    const directionToMouse = new THREE.Vector3().subVectors(mouse3D, p.mesh.position);
                    const distance = directionToMouse.length();

                    if (distance < mouseReactionRadius) {
                        const force = (mouseReactionRadius - distance) * mousePushForce;
                        directionToMouse.normalize().multiplyScalar(-force); // Push away
                        p.velocity.add(directionToMouse);
                    }
                }

                // Update position
                p.mesh.position.add(p.velocity);

                // Boundary collision (bounce off cube walls) and color change
                const halfBox = boxSize / 2;
                let collided = false;

                if (p.mesh.position.x + particleRadius > halfBox || p.mesh.position.x - particleRadius < -halfBox) {
                    p.velocity.x *= -1;
                    p.mesh.position.x = Math.max(-halfBox + particleRadius, Math.min(halfBox - particleRadius, p.mesh.position.x));
                    collided = true;
                }
                if (p.mesh.position.y + particleRadius > halfBox || p.mesh.position.y - particleRadius < -halfBox) {
                    p.velocity.y *= -1;
                    p.mesh.position.y = Math.max(-halfBox + particleRadius, Math.min(halfBox - particleRadius, p.mesh.position.y));
                    collided = true;
                }
                if (p.mesh.position.z + particleRadius > halfBox || p.mesh.position.z - particleRadius < -halfBox) {
                    p.velocity.z *= -1;
                    p.mesh.position.z = Math.max(-halfBox + particleRadius, Math.min(halfBox - particleRadius, p.mesh.position.z));
                    collided = true;
                }

                // Change color if collision occurred
                if (collided) {
                    const newColor = new THREE.Color();
                    const newHue = Math.random();
                    const newSaturation = 0.7 + Math.random() * 0.3;
                    const newLightness = 0.5 + Math.random() * 0.3;
                    newColor.setHSL(newHue, newSaturation, newLightness);
                    p.mesh.material.color.copy(newColor); // Update material color
                }
            }
        }

        // Event Handlers for particle pushing and shake gesture
        function onMouseMove(event) {
            if (!luckyParticleSelected && !simulationStarted) { // Only detect shake if simulation hasn't started
                const currentMouseX = event.clientX;
                const currentMouseY = event.clientY;

                const deltaX = Math.abs(currentMouseX - lastMouseX);
                const deltaY = Math.abs(currentMouseY - lastMouseY);

                if (deltaX > shakeThreshold || deltaY > shakeThreshold) {
                    shakeCount++;
                    clearTimeout(shakeTimeout); // Reset timer on new shake
                    shakeTimeout = setTimeout(() => {
                        shakeCount = 0; // Reset shake count if no new shakes within timeout
                    }, 200); // 200ms window for shakes

                    if (shakeCount >= maxShakeCount) {
                        simulationStarted = true; // Mark simulation as started
                        startCountdown();
                        shakeCount = 0; // Reset for next time
                        clearTimeout(shakeTimeout);
                    }
                }
                lastMouseX = currentMouseX;
                lastMouseY = currentMouseY;
            }

            // Existing mouse interaction for particle pushing
            if (!isDragging && !luckyParticleSelected) {
                const canvasRect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - canvasRect.left) / canvasRect.width) * 2 - 1;
                mouse.y = -((event.clientY - canvasRect.top) / canvasRect.height) * 2 + 1;

                let vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
                vector.unproject(camera);

                let dir = vector.sub(camera.position).normalize();
                let distance = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
                mouse3D.copy(camera.position).add(dir.multiplyScalar(distance));

                const halfBox = boxSize / 2;
                mouse3D.x = Math.max(-halfBox, Math.min(halfBox, mouse3D.x));
                mouse3D.y = Math.max(-halfBox, Math.min(halfBox, mouse3D.y));
                mouse3D.z = Math.max(-halfBox, Math.min(halfBox, mouse3D.z));

                mouse.isMoving = true;
                clearTimeout(mouse.timeout);
                mouse.timeout = setTimeout(() => {
                    mouse.isMoving = false;
                }, 50);
            }
        }

        function onMouseLeave() {
            mouse.isMoving = false;
            mouse3D.set(undefined, undefined, undefined);
        }

        // Event Handlers for cube rotation (mouse drag)
        function onMouseDown(event) {
            if (event.button === 0 && !luckyParticleSelected) { // Disable rotation if lucky particle is selected
                isDragging = true;
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
                renderer.domElement.classList.add('grabbing'); // Change cursor
            }
        }

        function onMouseDrag(event) {
            if (isDragging && !luckyParticleSelected) { // Disable rotation if lucky particle is selected
                const deltaX = event.clientX - previousMouseX;
                const deltaY = event.clientY - previousMouseY;

                cubeWireframe.rotation.y += deltaX * rotationSpeed;
                scene.rotation.y += deltaX * rotationSpeed;
                scene.rotation.x += deltaY * rotationSpeed;


                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            }
        }

        function onMouseUp(event) {
            isDragging = false;
            renderer.domElement.classList.remove('grabbing'); // Restore cursor
        }


        function onWindowResize() {
            const canvasElement = document.getElementById('particleCanvas');
            canvasElement.width = window.innerWidth * 0.9;
            canvasElement.height = window.innerHeight * 0.7;

            camera.aspect = canvasElement.width / canvasElement.height;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasElement.width, canvasElement.height);
        }

        // Function to update initial camera zoom (from slider)
        function updateInitialCameraZoom(value) {
            initialZoomValue = parseFloat(value);
            if (!luckyParticleSelected) { // Only apply if not in lucky particle mode
                camera.position.z = initialZoomValue;
                camera.updateProjectionMatrix();
            }
        }

        // Function to start the countdown
        function startCountdown() {
            clearInterval(countdownInterval); // Ensure any previous countdown is cleared
            countdownDisplay.style.display = 'block';
            countdownValue = 3;
            countdownDisplay.textContent = countdownValue;

            countdownInterval = setInterval(() => {
                countdownValue--;
                if (countdownValue > 0) {
                    countdownDisplay.textContent = countdownValue;
                } else {
                    countdownDisplay.textContent = 'GO!';
                    clearInterval(countdownInterval);
                    setTimeout(() => {
                        countdownDisplay.style.display = 'none';
                        autoSelectLuckyParticle(); // Trigger selection after "GO!"
                    }, 500); // Keep "GO!" visible for a moment
                }
            }, 1000); // Update every 1 second
        }

        // Function to automatically select a random particle and zoom/follow it
        function autoSelectLuckyParticle() {
            if (particles.length === 0) {
                showMessageBox('No particles to select from!');
                return;
            }

            const highestVelocityParticleIndex = findHighestVelocityParticleIndex();
            selectedParticle = particles[highestVelocityParticleIndex];

            // Apply explosive reveal (fading) to other particles
            explosionActive = true;
            particles.forEach(p => {
                if (p !== selectedParticle) {
                    p.mesh.material.transparent = true; // Enable transparency for fading
                }
            });

            // Create text mesh for the selected particle's number
            const textTexture = createTextTexture(String(selectedParticle.number), 'white', 128);
            const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true, side: THREE.DoubleSide });
            const textScaleFactor = 0.5;
            const textGeometry = new THREE.PlaneGeometry(
                textTexture.image.width / 100 * textScaleFactor,
                textTexture.image.height / 100 * textScaleFactor
            );
            selectedParticle.textMesh = new THREE.Mesh(textGeometry, textMaterial);
            scene.add(selectedParticle.textMesh);

            luckyParticleSelected = true;

            // Immediately set target camera position/lookAt for smooth transition
            targetCameraLookAt.copy(selectedParticle.mesh.position);
            const offset = new THREE.Vector3(0, 0, zoomInDistance);
            offset.applyQuaternion(selectedParticle.mesh.quaternion);
            targetCameraPosition.copy(selectedParticle.mesh.position).add(offset);
        }

        // Helper function to find the particle with the highest velocity
        function findHighestVelocityParticleIndex() {
            let maxSpeed = -1;
            let maxIndex = 0;
            for (let i = 0; i < particles.length; i++) {
                const speed = particles[i].velocity.length();
                if (speed > maxSpeed) {
                    maxSpeed = speed;
                    maxIndex = i;
                }
            }
            return maxIndex;
        }

        // Function to restart the simulation
        function restartSimulation() {
            // Clear any active countdown
            clearInterval(countdownInterval);
            countdownDisplay.style.display = 'none';
            countdownValue = 3;
            simulationStarted = false; // Reset simulation state
            explosionActive = false; // Reset explosion flag

            // Re-initialize particles and scene
            initParticles();

            // Reset camera to initial state
            camera.position.z = initialZoomValue;
            camera.position.y = boxSize * 0.2;
            camera.lookAt(0, 0, 0);

            // Ensure the initial interaction listener is re-added
            initialInteractionListenerAdded = false; // Allow it to be re-added
            addInitialInteractionListener();

            // Reset LLM output
            document.getElementById('llmOutput').textContent = 'Click a button to interact with the AI!';
        }

        // Function to call Gemini API and get particle insight
        async function getParticleInsight() {
            const llmOutputDiv = document.getElementById('llmOutput');
            llmOutputDiv.textContent = 'Generating insight...';

            const prompt = `Describe the behavior of a 3D particle system with the following characteristics in a concise and imaginative way (max 50 words):
- Number of particles: ${numberOfParticles}
- Average speed: ${particleSpeedFactor}
- Damping (how quickly they slow down naturally): ${damping}
- Mouse interaction radius: ${mouseReactionRadius}
- Mouse push force: ${mousePushForce}
- Initial whirlwind strength: ${whirlwindStrength}
- Inward spiral factor: ${inwardSpiralFactor}
- Particles never return to original position.
- Particle Color: HSL(${particleColorHue}, ${particleColorSaturation}%, ${particleColorLightness}%)
- Particle Shape: Sphere
- Particles slow down but never stop.
Focus on the overall visual impression and motion.`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    llmOutputDiv.textContent = text;
                } else {
                    llmOutputDiv.textContent = 'Failed to get insight. Please try again.';
                    console.error('Gemini API response structure unexpected:', result);
                    showMessageBox('Failed to get insight. Check console for details.');
                }
            } catch (error) {
                llmOutputDiv.textContent = 'Error generating insight.';
                console.error('Error calling Gemini API:', error);
                showMessageBox('Error calling Gemini API. Check console for details.');
            }
        }

        // Function to apply mood to particles using Gemini API
        async function applyMoodToParticles() {
            const moodInput = document.getElementById('moodInput');
            const llmOutputDiv = document.getElementById('llmOutput');
            const userMood = moodInput.value.trim();

            if (!userMood) {
                showMessageBox('Please enter a mood or theme!');
                return;
            }

            llmOutputDiv.textContent = `Applying "${userMood}" mood...`;

            const prompt = `Given the mood/theme '${userMood}', suggest numerical parameters for a 3D particle system to visually represent this mood. Provide values for:
- numberOfParticles (integer, 500-1500)
- particleSpeedFactor (float, 0.001-0.02)
- damping (float, 0.95-0.999)
- mouseReactionRadius (integer, 20-100)
- mousePushForce (float, 0.1-1.0)
- whirlwindStrength (float, 0.0001-0.005)
- inwardSpiralFactor (float, 0.00001-0.0005)
- particleColorHue (integer, 0-360)
- particleColorSaturation (integer, 50-100)
- particleColorLightness (integer, 30-90)
Also, provide a short description (max 30 words) of how these parameters evoke the mood. Ensure all values are within the specified ranges. Particles should never return to original position and slow down but never stop. Return as a JSON object.`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "numberOfParticles": { "type": "INTEGER" },
                            "particleSpeedFactor": { "type": "NUMBER" },
                            "damping": { "type": "NUMBER" },
                            "mouseReactionRadius": { "type": "INTEGER" },
                            "mousePushForce": { "type": "NUMBER" },
                            "whirlwindStrength": { "type": "NUMBER" },
                            "inwardSpiralFactor": { "type": "NUMBER" },
                            "particleColorHue": { "type": "INTEGER" },
                            "particleColorSaturation": { "type": "INTEGER" },
                            "particleColorLightness": { "type": "INTEGER" },
                            "description": { "type": "STRING" }
                        },
                        required: [
                            "numberOfParticles", "particleSpeedFactor", "damping",
                            "mouseReactionRadius", "mousePushForce", "whirlwindStrength",
                            "inwardSpiralFactor",
                            "particleColorHue", "particleColorSaturation",
                            "particleColorLightness", "description"
                        ]
                    }
                }
            };
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const parsedData = JSON.parse(jsonText);

                    // Apply new parameters
                    numberOfParticles = parsedData.numberOfParticles;
                    particleSpeedFactor = parsedData.particleSpeedFactor;
                    damping = parsedData.damping;
                    mouseReactionRadius = parsedData.mouseReactionRadius;
                    mousePushForce = parsedData.mousePushForce;
                    whirlwindStrength = parsedData.whirlwindStrength;
                    inwardSpiralFactor = parsedData.inwardSpiralFactor;
                    particleColorHue = parsedData.particleColorHue;
                    particleColorSaturation = parsedData.particleColorSaturation;
                    particleColorLightness = parsedData.particleColorLightness;

                    // Re-initialize particles with new parameters
                    initParticles();
                    llmOutputDiv.textContent = `Mood Applied! ${parsedData.description}`;
                } else {
                    llmOutputDiv.textContent = 'Failed to apply mood. Please try again.';
                    console.error('Gemini API response structure unexpected:', result);
                    showMessageBox('Failed to apply mood. Check console for details.');
                }
            } catch (error) {
                llmOutputDiv.textContent = 'Error applying mood.';
                console.error('Error calling Gemini API:', error);
                showMessageBox('Error calling Gemini API. Check console for details.');
            }
        }

        // Function to narrate the particle scene using Gemini API
        async function narrateParticleScene() {
            const llmOutputDiv = document.getElementById('llmOutput');
            llmOutputDiv.textContent = 'Generating narration...';

            let narrationPrompt = `Narrate a short, imaginative story or poem (max 60 words) about a 3D particle system. Focus on its current state:
- Number of particles: ${numberOfParticles}
- Particle speed: ${particleSpeedFactor} (consider its current dynamic state)
- Damping: ${damping} (how it affects motion)
- Mouse interaction: ${mouseReactionRadius > 0 ? 'present' : 'absent'}
- Lucky particle selected: ${selectedParticle ? 'Yes, particle ' + selectedParticle.number + ' is in focus.' : 'No lucky particle selected.'}
- Overall mood: Describe the visual and motion characteristics.`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: narrationPrompt }] });
            const payload = { contents: chatHistory };
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    llmOutputDiv.textContent = text;
                } else {
                    llmOutputDiv.textContent = 'Failed to generate narration. Please try again.';
                    console.error('Gemini API response structure unexpected:', result);
                    showMessageBox('Failed to generate narration. Check console for details.');
                }
            } catch (error) {
                llmOutputDiv.textContent = 'Error generating narration.';
                console.error('Error calling Gemini API:', error);
                showMessageBox('Error calling Gemini API. Check console for details.');
            }
        }

        // Initialize and start animation when the window loads
        window.onload = function() {
            initThreeJS();
            onWindowResize();
        };

    </script>
</body>
</html>
